// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               unknown
// source: janction/videoUpscaler/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

export const protobufPackage = "janction.videoUpscaler.v1";

/** Params defines the parameters of the module. */
export interface Params {
  minWorkerStaking?: Coin | undefined;
  maxWorkersPerThread: Long;
  minValidators: Long;
}

/** GenesisState is the state that must be provided at genesis. */
export interface GenesisState {
  /** params defines all the parameters of the module. */
  params?:
    | Params
    | undefined;
  /** Video Upscaler Task index */
  videoUpscalerTaskInfo?:
    | VideoUpscalerTaskInfo
    | undefined;
  /** List of Video Upscaler tasks */
  videoUpscalerTaskList: IndexedVideoUpscalerTask[];
  /** List of Workers */
  workers: Worker[];
}

export interface Worker {
  address: string;
  reputation?: Worker_Reputation | undefined;
  enabled: boolean;
  currentTaskId: string;
  currentThreadIndex: number;
  publicIp: string;
  ipfsId: string;
}

export interface Worker_Reputation {
  staked?: Coin | undefined;
  points: Long;
  validations: number;
  solutions: number;
  winnings?: Coin | undefined;
  renderDurations: Long[];
}

/**
 * Video Upscaler Task
 * @cid the IPFS CID submitted by a task requester
 */
export interface VideoUpscalerTask {
  taskId: string;
  requester: string;
  cid: string;
  startFrame: number;
  endFrame: number;
  threadAmount: number;
  completed: boolean;
  reward?: Coin | undefined;
  threads: VideoUpscalerThread[];
}

/**
 * A Video Upscaler Thread is the smallest unit of work for a Task.
 * Workers will try to complete a thread as soon as possible to submit first a solution
 */
export interface VideoUpscalerThread {
  threadId: string;
  taskId: string;
  startFrame: Long;
  endFrame: Long;
  completed: boolean;
  workers: string[];
  solution?: VideoUpscalerThread_Solution | undefined;
  validations: VideoUpscalerThread_Validation[];
  averageRenderSeconds: Long;
}

export interface VideoUpscalerThread_Solution {
  proposedBy: string;
  frames: VideoUpscalerThread_Frame[];
  publicKey: string;
  dir: string;
  accepted: boolean;
}

export interface VideoUpscalerThread_Validation {
  validator: string;
  frames: VideoUpscalerThread_Frame[];
  publicKey: string;
  isReverse: boolean;
}

export interface VideoUpscalerThread_Frame {
  filename: string;
  signature: string;
  cid: string;
  hash: string;
  validCount: Long;
  invalidCount: Long;
}

/** Stores information about the Video Upscaler  task */
export interface VideoUpscalerTaskInfo {
  nextId: Long;
}

/** Stores the Video Upscaler Task with the index */
export interface IndexedVideoUpscalerTask {
  index: string;
  videoUpscalerTask?: VideoUpscalerTask | undefined;
}

export interface VideoUpscalerLogs {
  threadId: string;
  logs: VideoUpscalerLogs_VideoUpscalerLog[];
}

export interface VideoUpscalerLogs_VideoUpscalerLog {
  log: string;
  timestamp: Long;
  severity: VideoUpscalerLogs_VideoUpscalerLog_SEVERITY;
}

export enum VideoUpscalerLogs_VideoUpscalerLog_SEVERITY {
  INFO = 0,
  SUCCESS = 1,
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function videoUpscalerLogs_VideoUpscalerLog_SEVERITYFromJSON(
  object: any,
): VideoUpscalerLogs_VideoUpscalerLog_SEVERITY {
  switch (object) {
    case 0:
    case "INFO":
      return VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.INFO;
    case 1:
    case "SUCCESS":
      return VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.SUCCESS;
    case 2:
    case "ERROR":
      return VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.UNRECOGNIZED;
  }
}

export function videoUpscalerLogs_VideoUpscalerLog_SEVERITYToJSON(
  object: VideoUpscalerLogs_VideoUpscalerLog_SEVERITY,
): string {
  switch (object) {
    case VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.INFO:
      return "INFO";
    case VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.SUCCESS:
      return "SUCCESS";
    case VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.ERROR:
      return "ERROR";
    case VideoUpscalerLogs_VideoUpscalerLog_SEVERITY.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseParams(): Params {
  return { minWorkerStaking: undefined, maxWorkersPerThread: Long.ZERO, minValidators: Long.ZERO };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minWorkerStaking !== undefined) {
      Coin.encode(message.minWorkerStaking, writer.uint32(10).fork()).join();
    }
    if (!message.maxWorkersPerThread.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.maxWorkersPerThread.toString());
    }
    if (!message.minValidators.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.minValidators.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minWorkerStaking = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxWorkersPerThread = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minValidators = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      minWorkerStaking: isSet(object.minWorkerStaking) ? Coin.fromJSON(object.minWorkerStaking) : undefined,
      maxWorkersPerThread: isSet(object.maxWorkersPerThread) ? Long.fromValue(object.maxWorkersPerThread) : Long.ZERO,
      minValidators: isSet(object.minValidators) ? Long.fromValue(object.minValidators) : Long.ZERO,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.minWorkerStaking !== undefined) {
      obj.minWorkerStaking = Coin.toJSON(message.minWorkerStaking);
    }
    if (!message.maxWorkersPerThread.equals(Long.ZERO)) {
      obj.maxWorkersPerThread = (message.maxWorkersPerThread || Long.ZERO).toString();
    }
    if (!message.minValidators.equals(Long.ZERO)) {
      obj.minValidators = (message.minValidators || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.minWorkerStaking = (object.minWorkerStaking !== undefined && object.minWorkerStaking !== null)
      ? Coin.fromPartial(object.minWorkerStaking)
      : undefined;
    message.maxWorkersPerThread = (object.maxWorkersPerThread !== undefined && object.maxWorkersPerThread !== null)
      ? Long.fromValue(object.maxWorkersPerThread)
      : Long.ZERO;
    message.minValidators = (object.minValidators !== undefined && object.minValidators !== null)
      ? Long.fromValue(object.minValidators)
      : Long.ZERO;
    return message;
  },
};

function createBaseGenesisState(): GenesisState {
  return { params: undefined, videoUpscalerTaskInfo: undefined, videoUpscalerTaskList: [], workers: [] };
}

export const GenesisState: MessageFns<GenesisState> = {
  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.videoUpscalerTaskInfo !== undefined) {
      VideoUpscalerTaskInfo.encode(message.videoUpscalerTaskInfo, writer.uint32(26).fork()).join();
    }
    for (const v of message.videoUpscalerTaskList) {
      IndexedVideoUpscalerTask.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.workers) {
      Worker.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoUpscalerTaskInfo = VideoUpscalerTaskInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.videoUpscalerTaskList.push(IndexedVideoUpscalerTask.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workers.push(Worker.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      videoUpscalerTaskInfo: isSet(object.videoUpscalerTaskInfo)
        ? VideoUpscalerTaskInfo.fromJSON(object.videoUpscalerTaskInfo)
        : undefined,
      videoUpscalerTaskList: globalThis.Array.isArray(object?.videoUpscalerTaskList)
        ? object.videoUpscalerTaskList.map((e: any) => IndexedVideoUpscalerTask.fromJSON(e))
        : [],
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => Worker.fromJSON(e)) : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.videoUpscalerTaskInfo !== undefined) {
      obj.videoUpscalerTaskInfo = VideoUpscalerTaskInfo.toJSON(message.videoUpscalerTaskInfo);
    }
    if (message.videoUpscalerTaskList?.length) {
      obj.videoUpscalerTaskList = message.videoUpscalerTaskList.map((e) => IndexedVideoUpscalerTask.toJSON(e));
    }
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => Worker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenesisState>, I>>(base?: I): GenesisState {
    return GenesisState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenesisState>, I>>(object: I): GenesisState {
    const message = createBaseGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.videoUpscalerTaskInfo =
      (object.videoUpscalerTaskInfo !== undefined && object.videoUpscalerTaskInfo !== null)
        ? VideoUpscalerTaskInfo.fromPartial(object.videoUpscalerTaskInfo)
        : undefined;
    message.videoUpscalerTaskList =
      object.videoUpscalerTaskList?.map((e) => IndexedVideoUpscalerTask.fromPartial(e)) || [];
    message.workers = object.workers?.map((e) => Worker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorker(): Worker {
  return {
    address: "",
    reputation: undefined,
    enabled: false,
    currentTaskId: "",
    currentThreadIndex: 0,
    publicIp: "",
    ipfsId: "",
  };
}

export const Worker: MessageFns<Worker> = {
  encode(message: Worker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.reputation !== undefined) {
      Worker_Reputation.encode(message.reputation, writer.uint32(26).fork()).join();
    }
    if (message.enabled !== false) {
      writer.uint32(32).bool(message.enabled);
    }
    if (message.currentTaskId !== "") {
      writer.uint32(42).string(message.currentTaskId);
    }
    if (message.currentThreadIndex !== 0) {
      writer.uint32(48).int32(message.currentThreadIndex);
    }
    if (message.publicIp !== "") {
      writer.uint32(58).string(message.publicIp);
    }
    if (message.ipfsId !== "") {
      writer.uint32(66).string(message.ipfsId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reputation = Worker_Reputation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currentTaskId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.currentThreadIndex = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.publicIp = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ipfsId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      reputation: isSet(object.reputation) ? Worker_Reputation.fromJSON(object.reputation) : undefined,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      currentTaskId: isSet(object.currentTaskId) ? globalThis.String(object.currentTaskId) : "",
      currentThreadIndex: isSet(object.currentThreadIndex) ? globalThis.Number(object.currentThreadIndex) : 0,
      publicIp: isSet(object.publicIp) ? globalThis.String(object.publicIp) : "",
      ipfsId: isSet(object.ipfsId) ? globalThis.String(object.ipfsId) : "",
    };
  },

  toJSON(message: Worker): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.reputation !== undefined) {
      obj.reputation = Worker_Reputation.toJSON(message.reputation);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.currentTaskId !== "") {
      obj.currentTaskId = message.currentTaskId;
    }
    if (message.currentThreadIndex !== 0) {
      obj.currentThreadIndex = Math.round(message.currentThreadIndex);
    }
    if (message.publicIp !== "") {
      obj.publicIp = message.publicIp;
    }
    if (message.ipfsId !== "") {
      obj.ipfsId = message.ipfsId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Worker>, I>>(base?: I): Worker {
    return Worker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Worker>, I>>(object: I): Worker {
    const message = createBaseWorker();
    message.address = object.address ?? "";
    message.reputation = (object.reputation !== undefined && object.reputation !== null)
      ? Worker_Reputation.fromPartial(object.reputation)
      : undefined;
    message.enabled = object.enabled ?? false;
    message.currentTaskId = object.currentTaskId ?? "";
    message.currentThreadIndex = object.currentThreadIndex ?? 0;
    message.publicIp = object.publicIp ?? "";
    message.ipfsId = object.ipfsId ?? "";
    return message;
  },
};

function createBaseWorker_Reputation(): Worker_Reputation {
  return {
    staked: undefined,
    points: Long.ZERO,
    validations: 0,
    solutions: 0,
    winnings: undefined,
    renderDurations: [],
  };
}

export const Worker_Reputation: MessageFns<Worker_Reputation> = {
  encode(message: Worker_Reputation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.staked !== undefined) {
      Coin.encode(message.staked, writer.uint32(10).fork()).join();
    }
    if (!message.points.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.points.toString());
    }
    if (message.validations !== 0) {
      writer.uint32(24).int32(message.validations);
    }
    if (message.solutions !== 0) {
      writer.uint32(32).int32(message.solutions);
    }
    if (message.winnings !== undefined) {
      Coin.encode(message.winnings, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.renderDurations) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Worker_Reputation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorker_Reputation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.staked = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.validations = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.solutions = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.winnings = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.renderDurations.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.renderDurations.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Worker_Reputation {
    return {
      staked: isSet(object.staked) ? Coin.fromJSON(object.staked) : undefined,
      points: isSet(object.points) ? Long.fromValue(object.points) : Long.ZERO,
      validations: isSet(object.validations) ? globalThis.Number(object.validations) : 0,
      solutions: isSet(object.solutions) ? globalThis.Number(object.solutions) : 0,
      winnings: isSet(object.winnings) ? Coin.fromJSON(object.winnings) : undefined,
      renderDurations: globalThis.Array.isArray(object?.renderDurations)
        ? object.renderDurations.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: Worker_Reputation): unknown {
    const obj: any = {};
    if (message.staked !== undefined) {
      obj.staked = Coin.toJSON(message.staked);
    }
    if (!message.points.equals(Long.ZERO)) {
      obj.points = (message.points || Long.ZERO).toString();
    }
    if (message.validations !== 0) {
      obj.validations = Math.round(message.validations);
    }
    if (message.solutions !== 0) {
      obj.solutions = Math.round(message.solutions);
    }
    if (message.winnings !== undefined) {
      obj.winnings = Coin.toJSON(message.winnings);
    }
    if (message.renderDurations?.length) {
      obj.renderDurations = message.renderDurations.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Worker_Reputation>, I>>(base?: I): Worker_Reputation {
    return Worker_Reputation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Worker_Reputation>, I>>(object: I): Worker_Reputation {
    const message = createBaseWorker_Reputation();
    message.staked = (object.staked !== undefined && object.staked !== null)
      ? Coin.fromPartial(object.staked)
      : undefined;
    message.points = (object.points !== undefined && object.points !== null)
      ? Long.fromValue(object.points)
      : Long.ZERO;
    message.validations = object.validations ?? 0;
    message.solutions = object.solutions ?? 0;
    message.winnings = (object.winnings !== undefined && object.winnings !== null)
      ? Coin.fromPartial(object.winnings)
      : undefined;
    message.renderDurations = object.renderDurations?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseVideoUpscalerTask(): VideoUpscalerTask {
  return {
    taskId: "",
    requester: "",
    cid: "",
    startFrame: 0,
    endFrame: 0,
    threadAmount: 0,
    completed: false,
    reward: undefined,
    threads: [],
  };
}

export const VideoUpscalerTask: MessageFns<VideoUpscalerTask> = {
  encode(message: VideoUpscalerTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.requester !== "") {
      writer.uint32(18).string(message.requester);
    }
    if (message.cid !== "") {
      writer.uint32(26).string(message.cid);
    }
    if (message.startFrame !== 0) {
      writer.uint32(32).int32(message.startFrame);
    }
    if (message.endFrame !== 0) {
      writer.uint32(40).int32(message.endFrame);
    }
    if (message.threadAmount !== 0) {
      writer.uint32(48).int32(message.threadAmount);
    }
    if (message.completed !== false) {
      writer.uint32(56).bool(message.completed);
    }
    if (message.reward !== undefined) {
      Coin.encode(message.reward, writer.uint32(66).fork()).join();
    }
    for (const v of message.threads) {
      VideoUpscalerThread.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requester = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.startFrame = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.endFrame = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.threadAmount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reward = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.threads.push(VideoUpscalerThread.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      requester: isSet(object.requester) ? globalThis.String(object.requester) : "",
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      startFrame: isSet(object.startFrame) ? globalThis.Number(object.startFrame) : 0,
      endFrame: isSet(object.endFrame) ? globalThis.Number(object.endFrame) : 0,
      threadAmount: isSet(object.threadAmount) ? globalThis.Number(object.threadAmount) : 0,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      reward: isSet(object.reward) ? Coin.fromJSON(object.reward) : undefined,
      threads: globalThis.Array.isArray(object?.threads)
        ? object.threads.map((e: any) => VideoUpscalerThread.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoUpscalerTask): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.requester !== "") {
      obj.requester = message.requester;
    }
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.startFrame !== 0) {
      obj.startFrame = Math.round(message.startFrame);
    }
    if (message.endFrame !== 0) {
      obj.endFrame = Math.round(message.endFrame);
    }
    if (message.threadAmount !== 0) {
      obj.threadAmount = Math.round(message.threadAmount);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.reward !== undefined) {
      obj.reward = Coin.toJSON(message.reward);
    }
    if (message.threads?.length) {
      obj.threads = message.threads.map((e) => VideoUpscalerThread.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerTask>, I>>(base?: I): VideoUpscalerTask {
    return VideoUpscalerTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerTask>, I>>(object: I): VideoUpscalerTask {
    const message = createBaseVideoUpscalerTask();
    message.taskId = object.taskId ?? "";
    message.requester = object.requester ?? "";
    message.cid = object.cid ?? "";
    message.startFrame = object.startFrame ?? 0;
    message.endFrame = object.endFrame ?? 0;
    message.threadAmount = object.threadAmount ?? 0;
    message.completed = object.completed ?? false;
    message.reward = (object.reward !== undefined && object.reward !== null)
      ? Coin.fromPartial(object.reward)
      : undefined;
    message.threads = object.threads?.map((e) => VideoUpscalerThread.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoUpscalerThread(): VideoUpscalerThread {
  return {
    threadId: "",
    taskId: "",
    startFrame: Long.ZERO,
    endFrame: Long.ZERO,
    completed: false,
    workers: [],
    solution: undefined,
    validations: [],
    averageRenderSeconds: Long.ZERO,
  };
}

export const VideoUpscalerThread: MessageFns<VideoUpscalerThread> = {
  encode(message: VideoUpscalerThread, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadId !== "") {
      writer.uint32(10).string(message.threadId);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (!message.startFrame.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.startFrame.toString());
    }
    if (!message.endFrame.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.endFrame.toString());
    }
    if (message.completed !== false) {
      writer.uint32(40).bool(message.completed);
    }
    for (const v of message.workers) {
      writer.uint32(50).string(v!);
    }
    if (message.solution !== undefined) {
      VideoUpscalerThread_Solution.encode(message.solution, writer.uint32(58).fork()).join();
    }
    for (const v of message.validations) {
      VideoUpscalerThread_Validation.encode(v!, writer.uint32(66).fork()).join();
    }
    if (!message.averageRenderSeconds.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.averageRenderSeconds.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerThread {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerThread();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startFrame = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endFrame = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.solution = VideoUpscalerThread_Solution.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.validations.push(VideoUpscalerThread_Validation.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.averageRenderSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerThread {
    return {
      threadId: isSet(object.threadId) ? globalThis.String(object.threadId) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      startFrame: isSet(object.startFrame) ? Long.fromValue(object.startFrame) : Long.ZERO,
      endFrame: isSet(object.endFrame) ? Long.fromValue(object.endFrame) : Long.ZERO,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => globalThis.String(e)) : [],
      solution: isSet(object.solution) ? VideoUpscalerThread_Solution.fromJSON(object.solution) : undefined,
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => VideoUpscalerThread_Validation.fromJSON(e))
        : [],
      averageRenderSeconds: isSet(object.averageRenderSeconds)
        ? Long.fromValue(object.averageRenderSeconds)
        : Long.ZERO,
    };
  },

  toJSON(message: VideoUpscalerThread): unknown {
    const obj: any = {};
    if (message.threadId !== "") {
      obj.threadId = message.threadId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (!message.startFrame.equals(Long.ZERO)) {
      obj.startFrame = (message.startFrame || Long.ZERO).toString();
    }
    if (!message.endFrame.equals(Long.ZERO)) {
      obj.endFrame = (message.endFrame || Long.ZERO).toString();
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.workers?.length) {
      obj.workers = message.workers;
    }
    if (message.solution !== undefined) {
      obj.solution = VideoUpscalerThread_Solution.toJSON(message.solution);
    }
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => VideoUpscalerThread_Validation.toJSON(e));
    }
    if (!message.averageRenderSeconds.equals(Long.ZERO)) {
      obj.averageRenderSeconds = (message.averageRenderSeconds || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerThread>, I>>(base?: I): VideoUpscalerThread {
    return VideoUpscalerThread.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerThread>, I>>(object: I): VideoUpscalerThread {
    const message = createBaseVideoUpscalerThread();
    message.threadId = object.threadId ?? "";
    message.taskId = object.taskId ?? "";
    message.startFrame = (object.startFrame !== undefined && object.startFrame !== null)
      ? Long.fromValue(object.startFrame)
      : Long.ZERO;
    message.endFrame = (object.endFrame !== undefined && object.endFrame !== null)
      ? Long.fromValue(object.endFrame)
      : Long.ZERO;
    message.completed = object.completed ?? false;
    message.workers = object.workers?.map((e) => e) || [];
    message.solution = (object.solution !== undefined && object.solution !== null)
      ? VideoUpscalerThread_Solution.fromPartial(object.solution)
      : undefined;
    message.validations = object.validations?.map((e) => VideoUpscalerThread_Validation.fromPartial(e)) || [];
    message.averageRenderSeconds = (object.averageRenderSeconds !== undefined && object.averageRenderSeconds !== null)
      ? Long.fromValue(object.averageRenderSeconds)
      : Long.ZERO;
    return message;
  },
};

function createBaseVideoUpscalerThread_Solution(): VideoUpscalerThread_Solution {
  return { proposedBy: "", frames: [], publicKey: "", dir: "", accepted: false };
}

export const VideoUpscalerThread_Solution: MessageFns<VideoUpscalerThread_Solution> = {
  encode(message: VideoUpscalerThread_Solution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposedBy !== "") {
      writer.uint32(10).string(message.proposedBy);
    }
    for (const v of message.frames) {
      VideoUpscalerThread_Frame.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    if (message.dir !== "") {
      writer.uint32(34).string(message.dir);
    }
    if (message.accepted !== false) {
      writer.uint32(40).bool(message.accepted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerThread_Solution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerThread_Solution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposedBy = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.frames.push(VideoUpscalerThread_Frame.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dir = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerThread_Solution {
    return {
      proposedBy: isSet(object.proposedBy) ? globalThis.String(object.proposedBy) : "",
      frames: globalThis.Array.isArray(object?.frames)
        ? object.frames.map((e: any) => VideoUpscalerThread_Frame.fromJSON(e))
        : [],
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      dir: isSet(object.dir) ? globalThis.String(object.dir) : "",
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
    };
  },

  toJSON(message: VideoUpscalerThread_Solution): unknown {
    const obj: any = {};
    if (message.proposedBy !== "") {
      obj.proposedBy = message.proposedBy;
    }
    if (message.frames?.length) {
      obj.frames = message.frames.map((e) => VideoUpscalerThread_Frame.toJSON(e));
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.dir !== "") {
      obj.dir = message.dir;
    }
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerThread_Solution>, I>>(base?: I): VideoUpscalerThread_Solution {
    return VideoUpscalerThread_Solution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerThread_Solution>, I>>(
    object: I,
  ): VideoUpscalerThread_Solution {
    const message = createBaseVideoUpscalerThread_Solution();
    message.proposedBy = object.proposedBy ?? "";
    message.frames = object.frames?.map((e) => VideoUpscalerThread_Frame.fromPartial(e)) || [];
    message.publicKey = object.publicKey ?? "";
    message.dir = object.dir ?? "";
    message.accepted = object.accepted ?? false;
    return message;
  },
};

function createBaseVideoUpscalerThread_Validation(): VideoUpscalerThread_Validation {
  return { validator: "", frames: [], publicKey: "", isReverse: false };
}

export const VideoUpscalerThread_Validation: MessageFns<VideoUpscalerThread_Validation> = {
  encode(message: VideoUpscalerThread_Validation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    for (const v of message.frames) {
      VideoUpscalerThread_Frame.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    if (message.isReverse !== false) {
      writer.uint32(32).bool(message.isReverse);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerThread_Validation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerThread_Validation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.frames.push(VideoUpscalerThread_Frame.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isReverse = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerThread_Validation {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      frames: globalThis.Array.isArray(object?.frames)
        ? object.frames.map((e: any) => VideoUpscalerThread_Frame.fromJSON(e))
        : [],
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      isReverse: isSet(object.isReverse) ? globalThis.Boolean(object.isReverse) : false,
    };
  },

  toJSON(message: VideoUpscalerThread_Validation): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.frames?.length) {
      obj.frames = message.frames.map((e) => VideoUpscalerThread_Frame.toJSON(e));
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.isReverse !== false) {
      obj.isReverse = message.isReverse;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerThread_Validation>, I>>(base?: I): VideoUpscalerThread_Validation {
    return VideoUpscalerThread_Validation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerThread_Validation>, I>>(
    object: I,
  ): VideoUpscalerThread_Validation {
    const message = createBaseVideoUpscalerThread_Validation();
    message.validator = object.validator ?? "";
    message.frames = object.frames?.map((e) => VideoUpscalerThread_Frame.fromPartial(e)) || [];
    message.publicKey = object.publicKey ?? "";
    message.isReverse = object.isReverse ?? false;
    return message;
  },
};

function createBaseVideoUpscalerThread_Frame(): VideoUpscalerThread_Frame {
  return { filename: "", signature: "", cid: "", hash: "", validCount: Long.ZERO, invalidCount: Long.ZERO };
}

export const VideoUpscalerThread_Frame: MessageFns<VideoUpscalerThread_Frame> = {
  encode(message: VideoUpscalerThread_Frame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    if (message.cid !== "") {
      writer.uint32(26).string(message.cid);
    }
    if (message.hash !== "") {
      writer.uint32(34).string(message.hash);
    }
    if (!message.validCount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.validCount.toString());
    }
    if (!message.invalidCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.invalidCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerThread_Frame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerThread_Frame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.invalidCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerThread_Frame {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      validCount: isSet(object.validCount) ? Long.fromValue(object.validCount) : Long.ZERO,
      invalidCount: isSet(object.invalidCount) ? Long.fromValue(object.invalidCount) : Long.ZERO,
    };
  },

  toJSON(message: VideoUpscalerThread_Frame): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (!message.validCount.equals(Long.ZERO)) {
      obj.validCount = (message.validCount || Long.ZERO).toString();
    }
    if (!message.invalidCount.equals(Long.ZERO)) {
      obj.invalidCount = (message.invalidCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerThread_Frame>, I>>(base?: I): VideoUpscalerThread_Frame {
    return VideoUpscalerThread_Frame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerThread_Frame>, I>>(object: I): VideoUpscalerThread_Frame {
    const message = createBaseVideoUpscalerThread_Frame();
    message.filename = object.filename ?? "";
    message.signature = object.signature ?? "";
    message.cid = object.cid ?? "";
    message.hash = object.hash ?? "";
    message.validCount = (object.validCount !== undefined && object.validCount !== null)
      ? Long.fromValue(object.validCount)
      : Long.ZERO;
    message.invalidCount = (object.invalidCount !== undefined && object.invalidCount !== null)
      ? Long.fromValue(object.invalidCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseVideoUpscalerTaskInfo(): VideoUpscalerTaskInfo {
  return { nextId: Long.ZERO };
}

export const VideoUpscalerTaskInfo: MessageFns<VideoUpscalerTaskInfo> = {
  encode(message: VideoUpscalerTaskInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.nextId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.nextId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerTaskInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerTaskInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nextId = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerTaskInfo {
    return { nextId: isSet(object.nextId) ? Long.fromValue(object.nextId) : Long.ZERO };
  },

  toJSON(message: VideoUpscalerTaskInfo): unknown {
    const obj: any = {};
    if (!message.nextId.equals(Long.ZERO)) {
      obj.nextId = (message.nextId || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerTaskInfo>, I>>(base?: I): VideoUpscalerTaskInfo {
    return VideoUpscalerTaskInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerTaskInfo>, I>>(object: I): VideoUpscalerTaskInfo {
    const message = createBaseVideoUpscalerTaskInfo();
    message.nextId = (object.nextId !== undefined && object.nextId !== null)
      ? Long.fromValue(object.nextId)
      : Long.ZERO;
    return message;
  },
};

function createBaseIndexedVideoUpscalerTask(): IndexedVideoUpscalerTask {
  return { index: "", videoUpscalerTask: undefined };
}

export const IndexedVideoUpscalerTask: MessageFns<IndexedVideoUpscalerTask> = {
  encode(message: IndexedVideoUpscalerTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== "") {
      writer.uint32(10).string(message.index);
    }
    if (message.videoUpscalerTask !== undefined) {
      VideoUpscalerTask.encode(message.videoUpscalerTask, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexedVideoUpscalerTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexedVideoUpscalerTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUpscalerTask = VideoUpscalerTask.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexedVideoUpscalerTask {
    return {
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      videoUpscalerTask: isSet(object.videoUpscalerTask)
        ? VideoUpscalerTask.fromJSON(object.videoUpscalerTask)
        : undefined,
    };
  },

  toJSON(message: IndexedVideoUpscalerTask): unknown {
    const obj: any = {};
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.videoUpscalerTask !== undefined) {
      obj.videoUpscalerTask = VideoUpscalerTask.toJSON(message.videoUpscalerTask);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IndexedVideoUpscalerTask>, I>>(base?: I): IndexedVideoUpscalerTask {
    return IndexedVideoUpscalerTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IndexedVideoUpscalerTask>, I>>(object: I): IndexedVideoUpscalerTask {
    const message = createBaseIndexedVideoUpscalerTask();
    message.index = object.index ?? "";
    message.videoUpscalerTask = (object.videoUpscalerTask !== undefined && object.videoUpscalerTask !== null)
      ? VideoUpscalerTask.fromPartial(object.videoUpscalerTask)
      : undefined;
    return message;
  },
};

function createBaseVideoUpscalerLogs(): VideoUpscalerLogs {
  return { threadId: "", logs: [] };
}

export const VideoUpscalerLogs: MessageFns<VideoUpscalerLogs> = {
  encode(message: VideoUpscalerLogs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadId !== "") {
      writer.uint32(10).string(message.threadId);
    }
    for (const v of message.logs) {
      VideoUpscalerLogs_VideoUpscalerLog.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerLogs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.threadId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logs.push(VideoUpscalerLogs_VideoUpscalerLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerLogs {
    return {
      threadId: isSet(object.threadId) ? globalThis.String(object.threadId) : "",
      logs: globalThis.Array.isArray(object?.logs)
        ? object.logs.map((e: any) => VideoUpscalerLogs_VideoUpscalerLog.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VideoUpscalerLogs): unknown {
    const obj: any = {};
    if (message.threadId !== "") {
      obj.threadId = message.threadId;
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => VideoUpscalerLogs_VideoUpscalerLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerLogs>, I>>(base?: I): VideoUpscalerLogs {
    return VideoUpscalerLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerLogs>, I>>(object: I): VideoUpscalerLogs {
    const message = createBaseVideoUpscalerLogs();
    message.threadId = object.threadId ?? "";
    message.logs = object.logs?.map((e) => VideoUpscalerLogs_VideoUpscalerLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVideoUpscalerLogs_VideoUpscalerLog(): VideoUpscalerLogs_VideoUpscalerLog {
  return { log: "", timestamp: Long.ZERO, severity: 0 };
}

export const VideoUpscalerLogs_VideoUpscalerLog: MessageFns<VideoUpscalerLogs_VideoUpscalerLog> = {
  encode(message: VideoUpscalerLogs_VideoUpscalerLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.log !== "") {
      writer.uint32(18).string(message.log);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp.toString());
    }
    if (message.severity !== 0) {
      writer.uint32(32).int32(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoUpscalerLogs_VideoUpscalerLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoUpscalerLogs_VideoUpscalerLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.log = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoUpscalerLogs_VideoUpscalerLog {
    return {
      log: isSet(object.log) ? globalThis.String(object.log) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      severity: isSet(object.severity) ? videoUpscalerLogs_VideoUpscalerLog_SEVERITYFromJSON(object.severity) : 0,
    };
  },

  toJSON(message: VideoUpscalerLogs_VideoUpscalerLog): unknown {
    const obj: any = {};
    if (message.log !== "") {
      obj.log = message.log;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.severity !== 0) {
      obj.severity = videoUpscalerLogs_VideoUpscalerLog_SEVERITYToJSON(message.severity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoUpscalerLogs_VideoUpscalerLog>, I>>(
    base?: I,
  ): VideoUpscalerLogs_VideoUpscalerLog {
    return VideoUpscalerLogs_VideoUpscalerLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoUpscalerLogs_VideoUpscalerLog>, I>>(
    object: I,
  ): VideoUpscalerLogs_VideoUpscalerLog {
    const message = createBaseVideoUpscalerLogs_VideoUpscalerLog();
    message.log = object.log ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.severity = object.severity ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
